## 一、阅读门槛
本教程基本没有学习门槛。因为在每道题目中，我都会尽量去串基础知识，以达到学以致用的效果。

<p align="center">
  <img width="400px" src="https://www.geekxh.com/assets/img/4.b038e351.gif">
</p>

## 二、期望达到什么样的目的

- 掌握基本的数据结构与算法
- 掌握各类型高频面试算法题

## 三、题解是围绕什么编写的

掌握！所有的题解都以掌握二字为前提。不会追求过多的奇淫技巧，毕竟我们不是专门研究算法的人。我见过太多算法初学者，一个题解看不懂，转头又去看第二个题解，第二个看不懂，又去看第三个，直到最后放弃掉。浪费了时间，题目还是不会做，这图什么呢？所以本教程所有的题解都是以<font color="deepPink">掌握为目标，尽量把每一道题的思路都讲的明明白白的。</font>

## 四、刷题顺序

一般刷题我们有两种策略，一种就是刷 leetcode 前一百道题目，另一种就是根据分类刷题。刷 leetcode 前一百道题，是因为这些题目都是经典题目。而根据分类，更适合算法小白和初中阶段读者。所以我在这里选择了根据分类来汇编，这样我们还可以在做一些题目的时候，与前面同类型的题目进行比较。

## 五、指导学习（i）
### 1. 算法意义
> 在实际项目中，算法的使用场景有很多，如“Java8中Hashmap使用红黑树来实现”、“Redis底层使用LRU来进做淘汰策略”、“大数据领域很多问题都基于TopK”、“JS原型链里使了类似链表的成环检测”、“特别复杂的业务逻辑经常涉及到DAG”、“MySql为什么索引要用B+树”、“Oracle里的开窗函数如何实现” 等等等等，这些今天我们统统不谈。而我，更多的是想和大家聊一聊，算法对个人有什么意义？

市面上大部分的算法书籍，第一章介绍算法，都会给大家列一列类似上面的那些话，或者就是使用栈或队列来做一个引子，告诉大家算法很重要，你得需要去学，吧啦吧啦....但是不知道大家有没有想过这样一个问题，算法对于个人而言到底有什么意义呢？如果这个问题大家陌生，那你一定会听到有写了几年业务逻辑的老程序员，说过“我这些年从来没有用过算法，除了出去面试的时候”之类的话。其实，我这里真想说一句脏话，这些思想真的是TMD害人不浅啊。甚至我怀疑大多数说这句话本身的人，有两种：一种就是严重缺乏自信心，觉得自己一辈子都没办法学好算法了，所以就这样吧。第二种就是故意误人子弟，驱动来源于自己不会，方式采用侃大山，反正忽悠一个是一个，再来身边也没有其他这方面厉害的朋友，说完之后自己都没意识到哪里有问题，却对别人带去很不好的影响。所以如果你今天看到我的这篇文章，我希望你能记住一世，这辈子都不要说出这种类似的话来，保持对这个学科基本的尊重，哪怕多一点点匠心精神。算法对个人的意义如下：

- 算法题目的程序规模大多都是比较小的，也就意味着切入点很小。使得每一个做题人，可以最大化的投入时间研究问题的本身。而在工作中，稍大一点的项目，基本上是没办法随意改变代码结构的，甚至还会为了整体性能牺牲程序的简洁与优雅。所以<font color="deepPink"> 算法题是可以让你通过练习编写出好代码的最好的方式，没有之一。</font>

- 算法题目中基本不会有图形化界面，只利用文本进行输入和输出。你可以相当专注的去解决问题。而在工作中，你能获得<font color="deepPink">专注去研究一个问题的机会</font>，几乎很难。想一想，假如你用JAVA写一个后台功能，其核心代码不到10行逻辑，但是MVC得占据你三分之一工作量，定义接口占据你三分之一工作量，公司假如没前端，再占据你三分之一工作量。整个这个过程，我有一个Amazon的朋友形容的很贴切，`“掏粪”`。

- <font color="deepPink">预测能力的构建</font>，在大多数算法练习平台中，因为会将运算时间和内存使用状况等信息实时提供给做题人，所以做题人甚至可以一边修改代码，一边观察修改对程序产生的影响。这个是不得了的，在工作中，绝对不可能有这样的机会。而在这个过程中，做题人可以提高<font color="deepPink">对逻辑结构复杂程序进行性能预测的能力，该能力将伴随其一身</font>。

- <font color="deepPink"> 提升coding能力的最好方式</font>。假如我们打王者荣耀，你要上王者，不开排位，一直打电脑，能上的去吗？在工作中，你来回接触的就那么几个人，有几个能写出特别优秀的代码，见到了，那说明老天眷顾你，大部分人都见不到。但是在算法平台的练习中，基本上我们每一个问题，我们都能看到全世界最优秀的人提交的代码。没有对比，虽然不成伤害，却更难成为进步！只有我们去<font color="deepPink"> 阅读别人优秀的逻辑，读懂别人思考的过程，与全世界顶尖的程序员编写代码的能力进行比较，才可以成为真正的大牛</font>。

- <font color="deepPink"> 算法题让你难受。</font> 用脚指头想一个问题，在各行各业中，想成为其行业的佼佼者，是不是一定有一个难受的过程。假如天天写CRUD，并且还得意洋洋，我用一套Generator生成只需要5分钟，其他时间就可以打打炉石，勾搭勾搭妹子。不经历一个难受的过程，如何可以进步？就连郭德纲出名之前，也在玻璃窗里被关过两天两夜。<font color="deepPink"> 罗马不是一天建成的，但是如果不修，那就永远建不成。难受就是真理，说明你正在进步。</font>

- <font color="deepPink"> 单测都是“骗人的”。</font> 请大家不要高估工作中QA的能力（当然，也有牛逼的QA，我见过...），大部分的公司里，QA来做单测时，基本上是重新走了一遍开发者的逻辑。更有甚者，开发直接说出“我写完都已经测完了，要QA有什么用处”，其实这并不是一个段子，因为大部分QA是做不到完美的cover业务逻辑的，换句话说，也就不可能构建出完美的测试用例测出你代码的问题。但是算法不是，大部分的算法平台，都提供了实时反馈的机制，如果自己编写的代码可以得到快速，客观的意见反馈，这绝对是有如神助。就好像是你打王者，旁边有个小精灵，总是会在合适的时机告诉你，“去下路，中路没人”，“小心草丛”。那如果不被带飞，你信吗？

总之，正是因为<font color="deepPink"> 算法题目中只保留了必备的要素，舍弃了其他无关紧要的部分，所以可以对每一位做题人都构建一个学习解决问题的最佳环境，</font> 而在这个环境中的成长与提高，将对一个软件工程师的生涯产生深远影响，乃至一世。所以，请大家能有一颗匠心，你可以选择不去了解学习掌握算法，但是请不要耽误他人进步。山高水长，江湖路远，珍重万千，有缘再见！

### 2. 解决问题的策略： 读题-重构-化简
> 解决简单的问题时，直接利用已知的技术便可轻松解决问题。但是如果遇到难题，恐怕就需要用各种手段。管他是花猫野猫，抓住耗子都是好猫。在解决问题的策略构建中，我们首先要对问题和答案结构有一个直观的感受，或者说猜测。如果可以把控住当前算法的问题，具备一个什么样的形态，然后就可以把毫无头绪的事情，变得有迹可循。在这样一个过程中，一点点的积累经验，最终就可以提升自己。

上面说的内容，玄而又玄，那到底如何来构建策略。假如我们遇到一个问题，让我们找一个国家铁路网中，两个城市的最短路径。这种问题，大家肯定首先想到的就是使用迪杰斯特拉算法。但是如果问题变成“换乘火车次数少于N次，寻找最短路径”，这种问题将不能直接套用最短路径的算法。有时候只是改变题中条件，就可以让整个题目完全走向另一个逻辑，这就需要大家对**原算法的原理和执行过程**特别了解，并且熟读题意。所以这里我们抽象出两个步骤：

- 读题
- 重构
- 化简

`读题`的目的，就是阅读并理解问题。不管是是不是算法老手，在这上面栽跟头的绝对不是一个两个，审题不清是所有人的共性（绝不是你的个人问题），人的天性就期望可以快速得到反馈，这是身体欲望导致的，和你看到漂亮的妹子下半身竖立本质没有什么区别。所以这就引出我们的解决方法 - 重构。

什么是`重构`，重构其实就是一个`抽象化`的过程。<font color="deepPink">借用我们已经掌握的数学/计算机知识，将其表达成现实世界概念。</font>大部分的现实世界概念都是比较复杂的，我们对其抽茧剥丝，保留本质，表述成易于理解的形式。而对其重构的过程，就可以决定其程序设计的方向。

<font color="RoyalBlue"> 举一个最简单的例子，比如我们要用代码实现一个整数平方根的开方，可以选用牛顿法或者二分法，那这两种方法是如何被想到的。假如我们把问题重构成图形的表达方式，就比较容易会推出牛顿法。假如我们把问题重构成已有的知识概念，自然就可以想到二分法。而如果我们把问题抽象成公式，甚至可以通过数学法来进行解题。</font>

划重点，<font color="deepPink">不同的重构方式，决定最终程序的走向</font>。

在重构的基础上，其实我们就可以来进行解题了。但是这里我还要对其加一个步骤，`化简`。什么又是化简，如何化简？假如我们有一个题，我们有一个二维网格，里边有N个点，两点的距离是X坐标和Y坐标的的和。比如坐标(5,1)和(4,7)的点间距就是1+6=7。我们要找到给出的N个点距离之和最小的新点的坐标。

<p align="center">
  <img width="400px" src="https://www.geekxh.com/assets/img/1.88792000.jpg">
</p>

题目因为本身是二维的，我们写代码其实不是很好写。所以我们可以将其化简为一维。我们把每一个点的左边，通过映射的方式，分别映射到 x轴 和 y轴。然后我们把**问题转化成在直线上寻找到给出点的距离之和最小的点**。这就是化简。万物之始，大道至简，至拙至美。生活中咱们也说透过现象看本质，放在算法里你就不会了？

### 3. 算法问题汇总

> 写算法最怕什么？当然是出错。与其重复相同的错误，不如从错误中吸取教训。与其从自己的错误中吸取教训，不如从别人的错误中学习经验。总结常见的算法问题，我总不能和你去说我们需要掌握数组、链表、二叉树、Map等这些数据结构。我认为的总结，就是错误的总结。所以为了快速拔高大家的水准，我准备了以下这些错误，请一定耐心看完，反复阅读。

- <font color="Gold"><b>递归，防止死循环和内存泄露</b></font>: 由于递归需要堆栈，所以<b>内存消耗要比非递归代码要大很多</b>。而且，如果递归深度太大，可能系统撑不住。内存会存在突然飙升的情况。如果是数据错误导致无限循环，那问题就大了。所以这方面问题在开发的时候需要注意。

- <font color="Gold"><b>访问数组越界</b></font>: 绝大多数的数组越界，根本原因在于对定义混淆。比如定义的时候想的是“以0起始”，但是写的时候写成了“以1起始”。究其根本，数组越界的问题，其实是对区间把控的问题。

- <font color="Gold"><b>区间表意不明</b></font>: 大部分的语言中，数组都以0为起始元素，但是人的思维习惯于以1为起始。那为什么数组要以0为起始元素，历史原因有很多，咱不说。对咱们有用的，3个。第一，因为我们选择左闭右开区间，比如 [0,n)，我们可以很容易通过 <font color="White"><b>n-0 得到数组中元素个数</b></font>。这点大家要形成条件发射，看到数组，明确其个数。第二，<font color="White"><b>闭区间很难去表示一个空数组</b></font>，不信你试试，非常难受。第三，<font color="White"><b>左闭右开的区间</b></font>，迭代器只需要最少的操作符。可以让代码写起来非常的舒服，STL的算法和容器中基本都是如此。

- <font color="Gold"><b>差一问题（栅栏错误）</b></font>: 建造一条直栅栏（即不围圈），长30米、每条栅栏柱间相隔3米，需要多少条栅栏柱? 求数组 A[i]到 A[j] 的平均值，A[i] 到 A[j] 的和应该除以多少，是 j-i+1，还是 j-i？二分法中的 while 条件，到底是用 <= 还是 < ？这些都是差一问题，这类问题如何解决。<font color="White"><b>利用最小的的输入值测试代码的执行过程，长期反复，达到条件反射。</b></font>这个过程一定是在大量的题目练习中掌握的，如果你到目前还在纠结这个问题，请先扣心自问，是否刷过至少200道算法题。如果没有，请不要纠结，干就对了。如果有，来找我。

- <font color="Gold"><b>内存溢出问题。</b></font> 分为两种，一种是因为运算超出变量取值范围发生的内存溢出，比如二分法中的mid，就要使用 left+(right-left)>>1。另一种就是因为代码不严谨，比如递归没有退出条件，while死循环，等等导致内存溢出。

- <font color="Gold"><b>初学者定义问题</b></font>:  比如统计26个字母出现的次数，初学者会用hashmap，其实这种已知值范围的，定义成数组就可以了。其他类似数字0-9，每个月的天数，都是一样的

- <font color="Gold"><b>写一半忘记题意</b></font>: 这个根本原因还是因为思维脉络不清晰导致的，有时候初学者还会遇到一个问题。定义一个函数，比如叫做 juge() 返回 bool 值，本来应该是判断某条件成立时返回true，但是用的时候却以为，在条件不成立的时候返回true，最终导致结果错误。

- <font color="Gold"><b>变量名错误</b></font>: 不管是和方法参数中的变量名称冲突，还是因为本身表意不明，最终出现赋值错误，或者编译不通过。

- <font color="Gold"><b>运算优先级错误</b></font>: 比如位运算，各个语言中的优先级定义是略有不同的。有时候需要加括号，有时候不需要加。

- <font color="Gold"><b>特殊值的处理</b></font>: 一些找规律的题目，往往在等于0，等于1的时候，规律和其他的数不同，所以这种题目，需要对这种特殊值进行特殊处理。

## 六、指导学习（ii）

### 1. 刷多少题

> 不下百人问过我这个问题。我的建议是，对于大部分的人，200道是一个合适的数字。

前面我已经说了，对于大部分人，我的建议是200道。大部分人指的是什么呢？我这里统指没有系统刷题经验的同学。无论是工作3-5年的职场老司机，还是即将毕业的应届生，只要没怎么刷过题，通通归为此类。

对于上面这个群体（请先自行判断是否可以归为此类），<font color="White"><b>刷题的目的基本是为了面试</b></font>。不管我多么巧舌如簧，告诉你算法可以提高思维，增强逻辑，是成为top coder的必然条件，等等等等。但最终都还是会回归到这个目的：`面试`。


### 2、为什么是200

> 这个问题，不妨换做 ”刷完200道题可以掌握到什么程度？“

常见tag无外乎那么七八种，200道题听起来很多，但是分散到每一个tag，每种也就只包含二三十个。倘若我们算多点，每一个tag包含30道题，其中大概是15-20道easy，5-10道medium，2-3道hard。200道不多不少，基本可以完美覆盖整个算法体系，所以我认为200道是一个不错的数字。

那么回到问题 “刷完200道题可以掌握到什么程度？” 我当然可以给你一些信心，告诉你200道题可以让你吊打面试官，完虐BAT。但是呢，其实这都是骗小孩子的，或者就是骗 ¥。那真实的200道题能让你到达一个什么程度呢？

- 在算法方面超过大概80%的同行（这里单指基础算法，非ML、AI等）
- 在面试时不至于对方拿出一道题目整个人就陷入懵逼，而是有资格享受面试思考题目的过程
- 身边有朋友聊到算法敢过去和他们交流，而不是默默的走开
- 对于应届生，谋取一份拿到offer的可能性
- 对于老司机，去大厂镀金的必备条件
- 对于培训生，极大的缩小和科班学生的差距

### 3. 200道刷多久

> “我之前立了个flag，一天刷一道都没坚持下来。你特么让我刷两百道，我一年都搞不定。这不扯淡吗？”

如果你有上面的疑惑，那么：你错了。坚持不下来一天一道的人和刷完200道题，毛关系都没有。回到我上面的例子，200道题目里。大概easy在130-150道左右，medium在30-50道，hard只占据了不到20道题。

跑步和刷题不同。跑步是越来越慢，刷题却是越来越快的。对于初学者（正常人），在每一个tag刷了10道左右简单题之后，基本同类型的题目可以提高到每天2-3道easy题目，有的掌握好的，甚至能提高到每天刷5-10题。很多同类型题目，基本都是一个模子刻出来的。

所以我认为，200道题刷的特别慢的话大概在150天左右完成，中不溜的在100天左右，刷的快的话在60天左右。同时，如果我们再把这里边的 medium 和 hard 通通remove 掉。再不济，也应该在3个月左右掌握大概100-150道简单题目。剩下的，just do it。

### 4. 刷完就忘

忘就对了。如果你在刷题的时候发现怎么也写不出来，别担心，这是正常的。如果你还发现，之前明明刷过的题，过段时间再做的时候，自己还是不会。别担心，这特么还是正常的。

所以如果有些题你刷了好多遍都还是不会，那就需要<font color="deepPink"> 进行总结。思考到底是哪一环节卡住了你，反复进行练习。</font> 当然，这里有人建议是每道题都刷个<font color="White"><b> 3遍</b></font>，其实我觉得倒是没有这个必要。我建议是找个小本本，记一下每一道的<font color="White"><b> 核心要素与考察要点。</b></font>在刷题的这段时间里，没啥事就瞅瞅翻翻。

### 5. 没基础怎么办
能。刷题本身就是一个学习的过程。比如二叉树的题，刷个30道，你一定会遇到BST。所以我个人认为学习系统的算法知识（也就是你们问我的，要不要买一本书，先看一遍再进行刷题）和 刷题 本身并不矛盾。你可以双管齐下，也可以单点突破，都ok。主要是，干就对了。

到这里就会出现另一个问题，“我是从头刷，还是分类刷？” 我的建议是，如果稍微有点算法基础，你就从头刷leetcode前200道题。如果完全没有算法基础，可以考虑分tag来刷。并不是说按照tag的方式更好，而是在没有算法基础的前提下分tag来刷，除了掌握题型之外，对于知识的掌握很有益处。（想一想初高中是如何学习的）那为什么又说从头刷也是可以的？这个是因为，如果一直刷某一种类型的题，容易出现刷完一类忘掉前一类的问题，也容易对某一类题目疲惫。总之，使用哪种方式取决于你。关键是：干就对了！

另外，我认为leetcode前200题是相当经典的。可能大家不知道，早期leetcode总共也就一百来道题。这些题目基本都是精华，后面的很多题目都是在这些题目的基础上进行演化而成。比如 合并两个有序链表，后来就演化成 合并K个有序链表。并且前200道题基本覆盖了所有的算法类型，我是很建议大家刷一遍的。

### 6. 知识与实践并进

- 基础知识： 熟练掌握计算机中的基本数据结构和核心算法的知识要点，了解其底层的代码实现
- 结合力扣练习题进行实际的操练
- 讲解业界实际应用

## 总结
回顾过去一年，京东、知乎、美团、微博、去哪儿、滴滴等。爆出裁员的有多少，虽然最终都被官方辟谣。但是，你们懂的。


互联网寒冬之下，所有公司都勒紧裤腰带过活。那么，对于个体的你，不努力，不学习，想去大厂？凭什么。


请大家原谅我说话的直白。2020年就目前来看，对于企业是明显的买方市场（供过于求）。而且，未来几年应该都是这样。所以，大部分企业在招聘时，是要在很多优秀的人中去选出一个更优秀的人，而不是在一群普通人中选择一个优秀的人。


毕竟，如果你不够格，可能简历都过不了。而对于应届生，如果不能多维度的获取你的信息。那么出几道难题，在没有更好的替代方案之前，目前是唯一的选择。


所以我最终很直白的告诉这位同学，刷题，你还是得刷。该记的，你还是得记。尤其如果目标本身就是一个好的offer，那更应是如此。


但是，这样的回答其实是不负责任的。虽然我考虑到给对方一点压力，很直白的回复了他。但如果放开这一切，我们为什么学算法？为什么学数据结构？


“面试造火箭，工作拧螺丝” ，工作四五年，别说红黑树，就连普通二叉树基本都没手写过，我知道很多人都是这个状态。这种状态正常吗？正常。但不写不等于不用。就算真的不用，也不等于不需要知道怎么用。


其实，很多学生学习数据结构是有问题的。就这位同学而言，至少出现背代码，就是绝对错误的。数据结构的本质，在我看来是去契合一些应用场景，自然而然的产生，而不是死记硬背。


比如说红黑树，我们需要知道这是一种常用的平衡二叉树（或者说特殊的平衡二叉树）知道其对于查找， 插入，删除的复杂度都是log(n) --- n 这里是说树中元素的个数。如果你是java栈，你可能还需要知道 hashmap 为什么选用红黑树来实现。要知道红黑树可以在一些非实时任务调度中，可以高效公平的调度任务。要知道其所有的应用，都是围绕着“平衡”二字。这才是数据结构的核心。


至于实现的细枝末节，知道固然好，但没必要去逼着自己记忆。因为，我们的职业生涯里，绝对不可能出现让你手写红黑树的节点删除的场景。


但你需要知道为什么创造/引入它，它有什么特殊的，它满足哪些场景，又不满足哪些场景，不满足的场景又如何替代。这才是对数据结构的良好理解。


其实，除了算法，在我看来很多别的知识也是这样。只是说算法，更容易在面试的时候去展示而已。本身而言，并没有什么特殊的。


比如学习操作系统。那我们为什么学习操作系统？难道是让我们造出来一个操作系统吗？显而易见并不是。学习操作系统是让我们了解为什么会提出OS，如果没有OS又会是什么样子。它怎么样做任务调度，怎么样做进程管理，怎么样对可用的硬件做成抽象，死锁是如何产生的，内存是怎么管理的，文件系统是如何实现的，通信是指谁与谁的通信。不是说应付了考试就算学了，而是带着脑子掌握这个东西的脉络，这才是核心。


比如学习数据库原理，不是说让你去造一个数据库。当然你有这本事，那也ok。更多的是去了解数据库是如何来抽象数据管理的，大数据在什么场景下应运而生。学了之后，你会知道关系型数据库只是数据库中的冰山一角。你知道缓存，索引，批处理，中间件之中都是有着数据库的影子。你用 git 你会知道 .git 文件下，其实就用几个很简单的数据结构，就构建了一个数据库的雏形。你知道事务控制，其实最初只是想把事情做正确，你知道 ACID 是在保证什么。你知道数据库的整个设计中，很多时候我们是在性能和正确性中做选择。你知道除了程序员之外，还有 DBA 更加会关注高可用。你不会再觉得读写分离，主从备份多么高大上，因为你知道除了读写分离之外，还有快慢分离，异地多活，Replication 和 Failover 很多东东，都是上个世纪就有了完美的理论支撑。


比如学习计算机网络，不是说让你去死记硬背几层网络模型，都各自是什么。而是让你知道全球互联网是如何运作的，知道TCP为了保证数据可靠做了多少额外的工作，握手为什么是3次，不是456次。知道滑动窗口并不等于leetcode上的几道题。知道层与层之间是如何划分的。知道在计算机网络的基础下，还有计算机网络安全一大块基石。


比如学习编译原理，没人让你死记硬背那些分词算法。而是去知道为什么要划分词法，语法，语义分析。知道为什么很多语言要提出中间代码这个东东。知道编译原理很多东西，其实就是 NLP 的基础，其实就是智能机器人的基础。知道在 ES 的设计中，其实也参考很多编译器的设计。


当然，我们很可能不会完美的掌握上面所说的所有。但我们会在这个过程中，去发现自己的知识盲点，进而刻意提高。而不是一直陷入“学不会-理解不了-记不住”的死循环。


当然，对于要找工作的人，我们可以直接去击打一些面试痛点，更好的兼容社会。但我们面试过后，总归是要知识落地，这才能体现你的最终价值。


不要说什么“面试造火箭，工作拧螺丝”，拧螺丝的人，只能一直留在位置上拧螺丝。而努力拧螺丝的人，说不定就有机会去造火箭。而那些有造火箭能力的人，他们终究会造上火箭。








