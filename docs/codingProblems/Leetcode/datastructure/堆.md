## 堆类型题总结
### Java 中的堆实现

```
<!-- c++ 堆实现 -->
可以直接用优先级队列priority_queue

默认是大顶堆 priority_queue<int> maxheap

小顶堆 priority_queue<int,vector<int>,greater<int>> minheap

也可以使用 multiset (使用multiset的情况一般为 需要从堆中删除元素，因为priority_queue的方法中没有 erase方法)

默认是小顶堆 multiset<int> minheap

大顶堆 multiset<int,greater<int>> maxheap
```

### 单堆问题
**指通过一个堆就可以解决的问题**
一般这种问题都具有以下特点：

求解第/前 k个最大，最小或是最频繁的元素；都可以使用堆来实现 （而不用通过排序实现）

**模式：**
确定大顶堆还是小顶堆

比如求 第K个最大元素，我们就用 大小为K的小顶堆，遍历数组完毕后，小顶堆堆顶元素即为第K个最大元素

遍历数组，压入小顶堆，判断小顶堆的元素个数，如果大于k，则弹出，保证小顶堆内元素个数始终是 k个

 

对于最频繁或是最不频繁的元素问题：可以首先结合 pair<int,int>对组 通过遍历统计，然后以 对组为 堆中元素进行 入堆

priority_queue<pair<int,int>,vector<pair<int,int>>,less<pair<int,int>>>  maxheap

 

比如：寻找第k个最大元素

求第k个最大元素，我们保留下来前k个最大元素即可，而前k个元素中我们又要最小的一个，所以我们可以使用小顶堆

保证小顶堆元素内个数不超过k即可，因为 随着我们压入元素，堆的大小增大，而小元素 一定在堆顶，所以 当堆的大小超过k时，就会 pop出去小元素，最后堆中剩下前k个大元素

### 双堆问题
**指通过两个堆相互配合解决问题**

被告知，我们拿到一大把可以分成两队的数字。怎么把数字分成两半？使得：小的数字都放在一起，大的放在另外一半。双堆模式就能高效解决此类问题。然后通过小顶堆寻找最小数据，大顶堆寻找堆中最大数据

这样中位数就可以通过 小顶堆和大顶堆堆顶元素求出

**模式**
比如求 数据流中的 中位数，因为 数据流一直在增加，所以如果采用排序，那么每一次增加元素后均需要再次排序，时间复杂度过高； 由于中位数 只需要知道中间两个数（或一个数）即可求出

我们可以使用 大顶堆 来存储 数据流中的 一半较小元素；用 小顶堆来存储 数据流中的 一般较大元素；

且保证 大顶堆的大小 大于 等于 小顶堆的大小，这样 如果 数据流大小为奇数，则返回 大顶堆 的堆顶元素即可，如果数据流大小为偶数，则 大顶堆和小顶堆元素取平均即可

如何实现？

//已知此时数据流元素个数为2k，大顶堆中存储较小元素，大顶堆存储较大元素

maxheap.push(val);//此时堆顶为大元素

将大元素 压入 小顶堆中

minheap.push(maxheap.top())

maxheap.pop()//从大顶堆中删除

//且要保证 大顶堆的大小不小于 小顶堆大小

while(maxheap.size() < minheap.size()) {将 小顶堆中元素压入大顶堆}

//最后通过验证数据流大小 来求中位数即可

## 题目框架
堆结构就是 用数组实现的完全二叉树,可以是数组的一部分形成了堆

一般是从0开始到某个下标index形成一个大根堆或者小根堆,堆的大小heapSize=index+1
如果从0下标开始,每个节点i,他的左子节点为:2i + 1,右子节点为:2i + 2, 他的父节点为 (i-1)/2;
排序过程的时间复杂度是O(nlgn)。因为建堆的时间复杂度是O(n)（调用一次）；调整堆的时间复杂度是lgn，调用了n-1次，所以堆排序的时间复杂度是O(nlgn)
java中默认是小根堆 使用lamada表达式可以获得大根堆PriorityQueue queue = new PriorityQueue<>((x, y)->y-x);
queue.offer(0) 入堆 queue.poll() 出堆 queue.peek()堆顶元素
queue.isEmpty() 是否为空
堆实际上就是一个随时能给你最大值的一个数据结构 当你不是想要全部的排序顺序序列的时候可能会有大用途 如top(k)问题

堆的难点在于 你怎么用这个给你排好序的 你个结构 你要拿什么进去做排序



## 01.数组中的第K个最大元素(215)

## 02.前 K 个高频元素(347)

## 03.数据流的中位数(295)

## 04.最低加油次数(871)



